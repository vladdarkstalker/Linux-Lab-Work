1. Запустить в консоли на выполнение две задачи, одну в интерактивном режиме, одну - в фоновом.
	1) `top` (интерактивный режим)
	2) `sleep 10 &` (& - фоновый режим)

2. Перевести одну из задач, выполняющихся в интерактивном режиме, в фоновый режим.
	1) `sleep 10`
	2) `CTRL+Z`
	3) `bg`

3.  Завершить выполнение двух процессов, владельцем которых является текущий пользователь. Первый процесс завершить с помощью сигнала SIGINT, задав его имя, второй — с помощью сигнала SIGQUIT, задав его номер.
	1) `killall –SIGINT sleep`
	2) `kill –SIGQUIT 20999`

4. Сгенерировать информацию — полный листинг о всех процессах системы.
	`pstree`

5. Завершить выполнение двух процессов, владельцем которых является текущий пользователь. Первый процесс завершить с помощью сигнала SIGTERM, задав его имя, второй — с помощью сигнала SIGKILL, задав его номер.
	1) `killall –SIGTERM sleep`
	2) `kill –SIGKILL 21008`

6. Определить идентификаторы процессов, владельцем которых не является root.
	`ps aux | grep -v root`

7. Сгенерировать следующую информацию о _m (m>2)_ процессах системы, имеющих значение идентификатора больше заданного _n:_ флаг — сведения о процессе, статус, PID, PPID, приоритет, использованное время и имя программы.
	1) `n=1000`
	2) `m=5`
	3) `ps -eo pid,ppid,stat,ni,time,cmd --sort=pid | awk -v n=$n -v m=$m 'BEGIN {count=0} $1 > n {count++; if (count <= m) print $1, $2, $3, $4, $5, $6}'`

8. Завершить выполнение двух процессов, владельцем которых является текущий пользователь. Первый процесс завершить с помощью сигнала SIGKILL, задав его имя, второй — с помощью сигнала SIGINT, задав его номер.
	1) `killall –SIGKILL sleep`
	2) `kill –SIGINT 20042`

9. Через символ « : » вывести идентификаторы процессов, для которых родителем является командный интерпретатор.
	`ps -eo ppid,pid,cmd | grep -E 'bash|sh' | awk '{print $2}' | xargs -I{} ps --ppid {} -o pid= | tr '\n' ':' | sed 's/:$//'`

10. С помощью сигнала SIGTSTP (используя комбинацию клавиш и команду kill) приостановить выполнение процесса, владельцем которого является текущий пользователь. Через несколько секунд возобновить выполнение процесса.
	1) `ps -u $(whoami)`
	2) `Ctrl+Z` или `kill -TSTP 2345`
	3) `kill -CONT 2345`

11. Вывести информацию о состоянии процессов системы в реальном режиме с обновлением один раз в 5 секунд. Отсортировать вывод по идентификатору пользователя по возрастанию и убыванию.
	1) `watch -n 5 'ps -eo user,uid,pid,ppid,stat,ni,time,cmd --sort=uid'` по возрастанию UID
	2) `watch -n 5 'ps -eo user,uid,pid,ppid,stat,ni,time,cmd | sort -k2'` по убыванию UID

12. Измените на 2 единицы приоритет процесса, запущенного из командного интерпретатора.
	1) `sudo renice +2 -p 1234` (увеличиваем на 2 единицы)
	2) `sudo renice -2 -p 1234` (уменьшаем на 2 единицы)

13. Сохранить в файл мгновенное состояние процессов системы указанного пользователя.
	`ps -u admin -o user,pid,ppid,stat,ni,time,cmd > processes.txt`

14. Послать сигнал SIGINT всем процессам, запущенным командой `vi` или `nano`.
	1) `pkill -SIGINT nano`
	2) `killall -2 vi`

15. Отобразить информацию о трех заданных процессах в реальном режиме, одному из процессов переназначить приоритет, не выходя из команды.
	1) `htop`
	2) `F3 для поиска процессов`
	3) `F7 для увеличения приоритета (снижения значения nice)`
	4) `F8 для уменьшения приоритета (повышения значения nice)`

16. Послать сигнал на безусловное завершение процессу по его имени, установить подтверждение завершения.
	1) `pkill -SIGKILL process_name`
	2) `killall -9 process_name`
	3) `ps -C process_name`

17. Определите информацию о работающем в системе пользователе (имя, время входа в систему, время простоя и т.д.).
	1) `w`
	2) `who`
	3) `finger`

18. Вывести статистику использования памяти в байтах с обновлением каждые три секунды.
	`watch -n 3 free -b`